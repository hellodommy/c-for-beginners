# Section 1: Introduction

## Terminology

CPU
* Does most of work
* Instructions executed here

RAM (random access memory)
* Stores data of program while it is running

Hard Drive (permanent storage)
* stores files that contain program source code *even when computer is turned off*

Operating System
* Make it more convenient to use computers
* Controls entire operations of computer
    * Input output
    * Manages resources and execution of programs

Fetch/Execute Cycle (life of CPU)
* Fetches instruction from memeory using registers and executes it (loop)
* Gigahertz CPU can do ~billion times a second

## High Level Programming Language
* Makes it easier to write prorgams
* Opposite of assembly language (ow level)
* Describe actions in a more abstract form
* No need to worry about precise steps for CPU (eg. MIPS)

### Compiler
* Translates high level source code into detailed set of machine language instructions the computer requires
* Program does high-level thinking, compiler generates tedious instructions to CPU
* Check that program has valid syntax, finds errors and reports them to you

## Writing a Program
1. Define program objectives
    * Understand requirements
2. Design the program
    * Decide how program will meet requirements
3. Write the code
    * Translate design in C syntax
4. Compile
5. Run program
    * Executable file is program you can run
6. Test and debug
7. Maintain and modify

Work in small steps and constantly test (divide and conquer).

## Overview
* General-purpose, imperative computer programming languages that support structured programming
* Organised around the use of functions (modular design)
* Preferred language for producing word processing programs, spreadsheets and compilers
* Strong role in the development of Linux
  * Virtually all new major OS are written in C and/or C++
* Easy to modify and to adapt to new models of lanugage
* Subset of C++ with OOP tools added (any C program is a valid C++ program)
* üåü Core skills needed by corporations and ranks in top 10 desired skills
* Provides constructs that map efficiently to typical machine instructions (provides low-level access to memory, requires minimal run-time support)
* Hardware independent (‚ùì what are some hardware dependent languages?)
  * Written in Standard C (there are C89, C99, C11)
  * Class will base examples and concepts off C11

## Efficiency and Portability
* Takes advantage of capabilities of current computers
* Programs are compact and fast (similar to assembly language programs)
* Programmers can fine-tune programs for maximum speed or most efficient use of memory
* Program written on one system cna be run on other system with little or no modification
* Compilers available for many computer architectures
* Linux/Unix systems typically come iwth a C compilers as part of the package

## Power and Flexibility
* Unix/Linux kernel in C
  * üìï Kernel - brain of OS
* Many compilers and interpreters (FORTRAN, Perl, Python, etc) written in C
* Flexible - but harder to understand, prone to mistakes
* Develop phone apps in Objective C
* Compact - easy to learn

## Programmer Oriented
* Access to hardware
* Enables manipulation of individual bits in memory
* Large selection of operators to express yourself succinctly 
* Less strict - many tasks are easier but prone to mistakes
* Implementations have large library of useful C functions

## Disadvantages
* Flexibiltiy and freedom requires added responsibiity
* Use of pointers is problematic and abused
* Programming errors dfifficult to trace
* Difficult to read and follow (opporunity to write obscure code)

## Creating a C Program
1. Editing
2. Compiling
3. Linking
4. Executing

* Same for developing programs in any environment with any compiled language
* All files end in `.c` extension

## Compiling
* Input to compiler is file you produce during editing (source file)
* Two-stage process
  1. Pre-processing phase, code may be modified or added to
  2. Actual compilation that generates object code
* Ensures code conforms to syntax and semantics of language
* Can recognise structural errors
* Does not find logic errors
* When fixed, compiler will take eachs statement and translate into assembly langugage, then translate into actual machien instructions
* Output is known as object code with `.obj` or `.o` extension
* Standard command to compile if `cc` or GNU compiler which is `.gcc`
* `cc -c my prog.c` or `gcc -c myprog.c`
* If omit `-c` flag, program will automatically be linked as well

## Linking
* After program has been translated to object code, it is ready to be linked
* Get program into final form for execution on computer
* Combines object modules generated by compiler with additional libraries needed by program to create the whole executable
* Failure means you need to go back and edit source code
* Success produces an executable file
  * Windows - `.exe` extension
  * Unix/Linux - `a.out` by default
* Program easier to manage by breaking it up into a number of smaller source files
  * Cohesive, makes development and maintenance easier
  * Set of source files will be integrated under a project name, which is used to refer to the whole program

## Executing
* Double click `.exe` file or type `a.out` on console in Linux manually
* Each statement sequentially executed
* Results displayed in a window called console
* üí• Can generate errors
  * Producing wrong output
  * Not doing anything
  * Crashing computer
